### 设置变量：

* 变量与变量内容以一个等号『=』来连结
* 等号两边不能直接接空格符
* 变量名称只能是英文字母与数字，但是开头字符不能是数字
* 变量内容若有空格符可使用双引号『"』或单引号『'』将变量内容结合起来，但
  > **o 双引号内的特殊字符如 $ 等，可以保有原本的特性，如下所示：**
  >
  > 『var="lang is $LANG"』则『echo $var』可得『lang is zh\_TW.UTF-8』
  >
  > **o 单引号内的特殊字符则仅为一般字符 \(纯文本\)，如下所示**：
  >
  > 『var='lang is $LANG'』则『echo $var』可得『lang is $LANG』
* 可用跳脱字符『  』将特殊符号\(如 \[Enter\], $, \, 空格符, '等\)变成一般字符，如：
  > 『myname=VBird Tsai』
* 在一串指令的执行中，还需要藉由其他额外的指令所提供的信息时，可以使用反单引号『\`指令\`』或 『$\(指令\)』。 例如想要取得核心版本的设定：

  > 『version=$\(uname -r\)』再『echo $version』可得『3.10.0-229.el7.x86\_64』

* 若该变量为扩增变量内容时，则可用 "$变量名称" 或 ${变量} 累加内容，如下所示：

  > 『PATH="$PATH":/home/bin』或『PATH=${PATH}:/home/bin』

* 若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量：

  > 『export PATH』

* 通常大写字符为系统默认变量，自行设定变量可以使用小写字符，方便判断 \(纯粹依照使用者兴趣与嗜好\) ；

### 取消变量：

将刚才设置的变量清除掉  
取消变量的方法为使用 unset ：『unset 变量名称』例如取消 myname 的设定：

> 『unset myname』

### 提取变量：

```
echo $varible
or
echo ${varible}
```

### 查看变量：

* 查看环境变量
  ```
  [dmtsai@study ~]$ env
  ```
* 用 set 观察所有变量 \(含环境变量与自定义变量\)
  ```
  [dmtsai@study ~]$ set
  ```

  不论是否为环境变量，只要跟我们目前这个 shell 的操作接口有关的变量， 通常都会被 设定为大写字符，也就是说，『基本上，在 Linux 预设的情况中，使用{大写的字母}来设定的变量 一般为系统内定需要的变量』。
  > ```
  > OK！OK！那么上头那些变量当中，有哪些是比较重要的？大概有
  > 这几个吧！
  > o PS1：(提示字符的设定)
  > 这是 PS1 (数字的 1 不是英文字母)，这个东西就是我们的『命令提示字符』喔！ 当我们每次按
  > 下 [Enter] 按键去执行某个指令后，最后要再次出现提示字符时，就会主动去读取这个变数值了。
  > 上头 PS1 内显示的是一些特殊符号，这些特殊符号可以显示不同的信息， 每个 distributions 的
  > bash 默认的 PS1 变量内容可能有些许的差异，不要紧，『习惯你自己的习惯』就好了。 你可以
  > 用 man bash (注 3)去查询一下 PS1 的相关说明，以理解底下的一些符号意义。
  >  \d ：可显示出『星期 月 日』的日期格式，如："Mon Feb 2"
  >  \H ：完整的主机名。举例来说，鸟哥的练习机为『study.centos.vbird』
  >  \h ：仅取主机名在第一个小数点之前的名字，如鸟哥主机则为『study』后面省略
  >  \t ：显示时间，为 24 小时格式的『HH:MM:SS』
  >  \T ：显示时间，为 12 小时格式的『HH:MM:SS』
  >  \A ：显示时间，为 24 小时格式的『HH:MM』
  >  \@ ：显示时间，为 12 小时格式的『am/pm』样式
  >  \u ：目前使用者的账号名称，如『dmtsai』；
  >  \v ：BASH 的版本信息，如鸟哥的测试主机版本为 4.2.46(1)-release，仅取『4.2』显示
  >  \w ：完整的工作目录名称，由根目录写起的目录名称。但家目录会以 ~ 取代；
  >  \W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。
  >  \# ：下达的第几个指令。
  >  \$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 啰～
  > 好了，让我们来看看 CentOS 预设的 PS1 内容吧：『[\u@\h \W]\$ 』，现在你知道那些反斜杠后
  > 的数据意义了吧？ 要注意喔！那个反斜杠后的数据为 PS1 的特殊功能，与 bash 的变量设定没
  > 关系啦！不要搞混了喔！ 那你现在知道为何你的命令提示字符是：『 [dmtsai@study ~]$ 』了吧？
  > 好了，那么假设我想要有类似底下的提示字符：
  > [dmtsai@study /home/dmtsai 16:50 #12]$
  > 那个 # 代表第 12 次下达的指令。那么应该如何设定 PS1 呢？可以这样啊：
  > [dmtsai@study ~]$ cd /home
  > [dmtsai@study home]$ PS1='[\u@\h \w \A #\#]\$ '
  > [dmtsai@study /home 17:02 #85]$
  > # 看到了吗？提示字符变了！变的很有趣吧！其中，那个 #85 比较有趣，
  > # 如果您再随便输入几次 ls 后，该数字就会增加喔！为啥？上面有说明滴！
  > o $：(关于本 shell 的 PID)
  > 钱字号本身也是个变量喔！这个咚咚代表的是『目前这个 Shell 的线程代号』，亦即是所谓的 PID
  > (Process ID)。 更多的程序观念，我们会在第四篇的时候提及。想要知道我们的 shell 的 PID ，
  > 就可以用：『 echo $$ 』即可！出现的数字就是你的 PID 号码。
  > o ?：(关于上个执行指令的回传值)
  > 虾密？问号也是一个特殊的变数？没错！在 bash 里面这个变量可重要的很！ 这个变数是：『上
  > 一个执行的指令所回传的值』， 上面这句话的重点是『上一个指令』与『回传值』两个地方。当
  > 我们执行某些指令时，这些指令都会回传一个执行后的代码。一般来说，如果成功的执行该指令，
  > 则会回传一个 0 值，如果执行过程发生错误，就会回传『错误代码』才对！一般就是以非为 0 的
  > 数值来取代。 我们以底下的例子来看看：
  > [dmtsai@study ~]$ echo $SHELL
  > /bin/bash <==可顺利显示！没有错误！
  > [dmtsai@study ~]$ echo $?
  > 0 <==因为没问题，所以回传值为 0
  > [dmtsai@study ~]$ 12name=VBird
  > bash: 12name=VBird: command not found... <==发生错误了！bash 回报有问题
  > [dmtsai@study ~]$ echo $?
  > 127 <==因为有问题，回传错误代码(非为 0)
  > # 错误代码回传值依据软件而有不同，我们可以利用这个代码来搜寻错误的原因喔！
  > [dmtsai@study ~]$ echo $?
  > 0
  > # 咦！怎么又变成正确了？这是因为 "?" 只与『上一个执行指令』有关，
  > # 所以，我们上一个指令是执行『 echo $? 』，当然没有错误，所以是 0 没错！
  > o OSTYPE, HOSTTYPE, MACHTYPE：(主机硬件与核心的等级)
  > 我们在第零章、计算器概论内的 CPU 等级说明中谈过 CPU ， 目前个人计算机的 CPU 主要分
  > 为 32/64 位，其中 32 位又可分为 i386, i586, i686，而 64 位则称为 x86_64。 由于不同等级的
  > CPU 指令集不太相同，因此你的软件可能会针对某些 CPU 进行优化，以求取较佳的软件性能。
  > 所以软件就有 i386, i686 及 x86_64 之分。以目前 (2015) 的主流硬件来说，几乎都是 x86_64 的
  > 天下！ 因此 CentOS 7 开始，已经不支持 i386 兼容模式的安装光盘了～哇呜！进步的太快了！
  > 要留意的是，较高阶的硬件通常会向下兼容旧有的软件，但较高阶的软件可能无法在旧机器上面
  > 安装！ 我们在第二章就曾说明过， 这里再强调一次，你可以在 x86_64 的硬件上安装 i386 的
  > Linux 操作系统，但是你无法在 i686 的硬件上安装 x86_64 的 Linux 操作系统！这点得要牢记
  > 在心！
  > ```

###  export： 自定义变量转成环境变量

 谈了 env 与 set 现在知道有所谓的环境变量与自定义变量，那么这两者之间有啥差异呢？其实这两 者的差异在于『 该变量是否会被子程序所继续引用』啦！唔！那么啥是父程序？子程序？ 这就得要 了解一下指令的下达行为了。 当你登入 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，这个程序的识别使用的是 一个称为程序标识符，被称为 PID 的就是。 接下来你在这个 bash 底下所下达的任何指令都是由这 个 bash 所衍生出来的，那些被下达的指令就被称为子程序了。 我们可以用底下的图示来简单的说 明一下父程序与子程序的概念：

![](/assets/import.png) 

如上所示，我们在原本的 bash 底下执行另一个 bash ，结果操作的环境接口会跑到第二个 bash 去 \(就是子程序\)， 那原本的 bash 就会在暂停的情况 \(睡着了，就是 sleep\)。整个指令运作的环境是实 线的部分！若要回到原本的 bash 去， 就只有将第二个 bash 结束掉 \(下达 exit 或 logout\) 才行。 更多的程序概念我们会在第四篇谈及，这里只要有这个概念即可。 这个程序概念与变量有啥关系啊？关系可大了！因为子程序仅会继承父程序的环境变量， 子程序不 会继承父程序的自定义变量啦！所以你在原本 bash 的自定义变量在进入了子程序后就会消失不见， 一直到你离开子程序并回到原本的父程序后，这个变量才会又出现！ 换个角度来想，也就是说，如果我能将自定义变量变成环境变量的话，那不就可以让该变量值继续存 在于子程序了？ 呵呵！没错！此时，那个 export 指令就很有用啦！如你想要让该变量内容继续的在 子程序中使用，那么就请执行：

```
[dmtsai@study ~]$ export 变量名称
```

 这东西用在『分享自己的变量设定给后来呼叫的文件或其他程序』啦！ 像鸟哥常常在自己的主控文 件后面呼叫其他附属文件\(类似函式的功能\)，但是主控文件与附属文件内都有相同的变量名称， 若 一再重复设定时，要修改也很麻烦，此时只要在原本的第一个文件内设定好『 export 变量 』， 后 面所呼叫的文件就能够使用这个变量设定了！而不需要重复设定，这非常实用于 shell script 当中喔！ 如果仅下达 export 而没有接变量时，那么此时将会把所有的『环境变量』秀出来喔！例如：

```
[dmtsai@study ~]$ export
declare -x HISTSIZE="1000"
declare -x HOME="/home/dmtsai"
declare -x HOSTNAME="study.centos.vbird"
declare -x LANG="zh_TW.UTF-8"
declare -x LC_ALL="en_US.utf8"    
```



