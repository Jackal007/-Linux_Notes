### 提取变量：

```
echo $varible
or
echo ${varible}
```

> 使用变量来做数值运算的时候要加双括号
>
> ```
> s=$((${s}+${i}))
> ```

### 查看变量：

* 查看环境变量
  ```
  [dmtsai@study ~]$ env
  ```
* 用 set 观察所有变量 \(含环境变量与自定义变量\)

  ```
  [dmtsai@study ~]$ set
  ```

  不论是否为环境变量，只要跟我们目前这个 shell 的操作接口有关的变量， 通常都会被 设定为大写字符，也就是说，『基本上，在 Linux 预设的情况中，使用{大写的字母}来设定的变量 一般为系统内定需要的变量』。

  > ```
  > OK！OK！那么上头那些变量当中，有哪些是比较重要的？大概有
  > 这几个吧！
  > o PS1：(提示字符的设定)
  > 这是 PS1 (数字的 1 不是英文字母)，这个东西就是我们的『命令提示字符』喔！ 当我们每次按
  > 下 [Enter] 按键去执行某个指令后，最后要再次出现提示字符时，就会主动去读取这个变数值了。
  > 上头 PS1 内显示的是一些特殊符号，这些特殊符号可以显示不同的信息， 每个 distributions 的
  > bash 默认的 PS1 变量内容可能有些许的差异，不要紧，『习惯你自己的习惯』就好了。 你可以
  > 用 man bash (注 3)去查询一下 PS1 的相关说明，以理解底下的一些符号意义。
  >  \d ：可显示出『星期 月 日』的日期格式，如："Mon Feb 2"
  >  \H ：完整的主机名。举例来说，鸟哥的练习机为『study.centos.vbird』
  >  \h ：仅取主机名在第一个小数点之前的名字，如鸟哥主机则为『study』后面省略
  >  \t ：显示时间，为 24 小时格式的『HH:MM:SS』
  >  \T ：显示时间，为 12 小时格式的『HH:MM:SS』
  >  \A ：显示时间，为 24 小时格式的『HH:MM』
  >  \@ ：显示时间，为 12 小时格式的『am/pm』样式
  >  \u ：目前使用者的账号名称，如『dmtsai』；
  >  \v ：BASH 的版本信息，如鸟哥的测试主机版本为 4.2.46(1)-release，仅取『4.2』显示
  >  \w ：完整的工作目录名称，由根目录写起的目录名称。但家目录会以 ~ 取代；
  >  \W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。
  >  \# ：下达的第几个指令。
  >  \$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 啰～
  > 好了，让我们来看看 CentOS 预设的 PS1 内容吧：『[\u@\h \W]\$ 』，现在你知道那些反斜杠后
  > 的数据意义了吧？ 要注意喔！那个反斜杠后的数据为 PS1 的特殊功能，与 bash 的变量设定没
  > 关系啦！不要搞混了喔！ 那你现在知道为何你的命令提示字符是：『 [dmtsai@study ~]$ 』了吧？
  > 好了，那么假设我想要有类似底下的提示字符：
  > [dmtsai@study /home/dmtsai 16:50 #12]$
  > 那个 # 代表第 12 次下达的指令。那么应该如何设定 PS1 呢？可以这样啊：
  > [dmtsai@study ~]$ cd /home
  > [dmtsai@study home]$ PS1='[\u@\h \w \A #\#]\$ '
  > [dmtsai@study /home 17:02 #85]$
  > # 看到了吗？提示字符变了！变的很有趣吧！其中，那个 #85 比较有趣，
  > # 如果您再随便输入几次 ls 后，该数字就会增加喔！为啥？上面有说明滴！
  > o $：(关于本 shell 的 PID)
  > 钱字号本身也是个变量喔！这个咚咚代表的是『目前这个 Shell 的线程代号』，亦即是所谓的 PID
  > (Process ID)。 更多的程序观念，我们会在第四篇的时候提及。想要知道我们的 shell 的 PID ，
  > 就可以用：『 echo $$ 』即可！出现的数字就是你的 PID 号码。
  > o ?：(关于上个执行指令的回传值)
  > 虾密？问号也是一个特殊的变数？没错！在 bash 里面这个变量可重要的很！ 这个变数是：『上
  > 一个执行的指令所回传的值』， 上面这句话的重点是『上一个指令』与『回传值』两个地方。当
  > 我们执行某些指令时，这些指令都会回传一个执行后的代码。一般来说，如果成功的执行该指令，
  > 则会回传一个 0 值，如果执行过程发生错误，就会回传『错误代码』才对！一般就是以非为 0 的
  > 数值来取代。 我们以底下的例子来看看：
  > [dmtsai@study ~]$ echo $SHELL
  > /bin/bash <==可顺利显示！没有错误！
  > [dmtsai@study ~]$ echo $?
  > 0 <==因为没问题，所以回传值为 0
  > [dmtsai@study ~]$ 12name=VBird
  > bash: 12name=VBird: command not found... <==发生错误了！bash 回报有问题
  > [dmtsai@study ~]$ echo $?
  > 127 <==因为有问题，回传错误代码(非为 0)
  > # 错误代码回传值依据软件而有不同，我们可以利用这个代码来搜寻错误的原因喔！
  > [dmtsai@study ~]$ echo $?
  > 0
  > # 咦！怎么又变成正确了？这是因为 "?" 只与『上一个执行指令』有关，
  > # 所以，我们上一个指令是执行『 echo $? 』，当然没有错误，所以是 0 没错！
  > o OSTYPE, HOSTTYPE, MACHTYPE：(主机硬件与核心的等级)
  > 我们在第零章、计算器概论内的 CPU 等级说明中谈过 CPU ， 目前个人计算机的 CPU 主要分
  > 为 32/64 位，其中 32 位又可分为 i386, i586, i686，而 64 位则称为 x86_64。 由于不同等级的
  > CPU 指令集不太相同，因此你的软件可能会针对某些 CPU 进行优化，以求取较佳的软件性能。
  > 所以软件就有 i386, i686 及 x86_64 之分。以目前 (2015) 的主流硬件来说，几乎都是 x86_64 的
  > 天下！ 因此 CentOS 7 开始，已经不支持 i386 兼容模式的安装光盘了～哇呜！进步的太快了！
  > 要留意的是，较高阶的硬件通常会向下兼容旧有的软件，但较高阶的软件可能无法在旧机器上面
  > 安装！ 我们在第二章就曾说明过， 这里再强调一次，你可以在 x86_64 的硬件上安装 i386 的
  > Linux 操作系统，但是你无法在 i686 的硬件上安装 x86_64 的 Linux 操作系统！这点得要牢记
  > 在心！
  > ```



